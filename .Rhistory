cormat <- cor(myD[,-1])
round(cormat, 2)
library(reshape2)
melted_cormat <- melt(cormat)
head(melted_cormat)
library(ggplot2)
ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + geom_tile()
get_lower_tri<-function(cormat){
cormat[upper.tri(cormat)] <- NA
return(cormat)
}
upper_tri <- get_lower_tri(cormat)
upper_tri
melted_cormat <- melt(upper_tri, na.rm = TRUE)
ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# reorder the correlation values
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
# get lower triangle of the matrix
get_lower_tri<-function(cormat){
cormat[upper.tri(cormat)] <- NA
return(cormat)
}
# reorder the correlation values
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
# pair matrix without dates
cormat <- cor(myD[,-1])
round(cormat, 2)
melted_cormat <- melt(cormat)
cormat <- reorder_cormat(cormat)
upper_tri <- get_lower_tri(cormat)
# upper_tri
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# create correlation heatmap
ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
melted_cormat
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))
# create correlation heatmap
ggheatmap <- ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
ggheatmap +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.ticks = element_blank(),
legend.justification = c(1, 0),
legend.position = c(0.6, 0.7),
legend.direction = "horizontal")+
guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
title.position = "top", title.hjust = 0.5))
# create correlation heatmap
ggheatmap <- ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# Math 564 project
# read data
library(ggplot2)
library(reshape2)
setwd("C:/Users/Jin/Desktop/MATH564Project")
myD<-read.csv("kc_house_data.csv",stringsAsFactors = FALSE)
summary(myD)
str(myD)
myD$date <- as.Date(substring(myD$date, 0, 8), "%Y%m%d")
myD <- myD[, -1]
write.csv(myD, file = "kc_house_data_cleaned.csv")
# pair matrix without dates
cormat <- cor(myD[,-1])
round(cormat, 2)
melted_cormat <- melt(cormat)
cormat <- reorder_cormat(cormat)
upper_tri <- get_lower_tri(cormat)
# upper_tri
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# create correlation heatmap
ggheatmap <- ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# approach the data with a easy linear model
basic_fit <- lm(price~., data = myD)
summary(basic_fit)
# coef of sqft_basemeng is NA
# forward, backward variable selection
##############################################
# helper functions
# get lower triangle of the matrix
get_lower_tri<-function(cormat){
cormat[upper.tri(cormat)] <- NA
return(cormat)
}
# reorder the correlation values
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
ggheatmap
melted_cormat
# ggheatmap
melted_cormat[order(melted_cormat$value)]
# ggheatmap
melted_cormat[,order(melted_cormat$value)]
# ggheatmap
melted_cormat[order(melted_cormat$value),]
??order
##correlations
# pair matrix without dates
cormat <- cor(myD[,-1])
library(corrplot)
corrMatOrder(cormat)
# ggheatmap
melted_cormat[order(melted_cormat$value, decreasing = T),]
# ggheatmap
melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
##
boxplot1=boxplot(price~sqft_living, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
#
melted_cormat[order(abs(melted_cormat$value), decreasing = T), melted_cormat$Var1 = 'price']
#
melted_cormat[order(abs(melted_cormat$value), decreasing = T), melted_cormat$Var1]
#
melted_cormat[order(abs(melted_cormat$value), decreasing = T), order(melted_cormat$Var1)]
#
melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
##
boxplot_p_sl <- boxplot(price~sqft_living, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_b
boxplot_p_b <- boxplot(price~bathrooms, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_g <- boxplot(price~grade, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_b <- boxplot(price~bathrooms, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Bathrooms", xlab="Bathrooms", ylab="Price")
boxplot_p_g <- boxplot(price~grade, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Grade", xlab="Grade", ylab="Price")
melted_cormat[melted_cormat$Var1,]
melted_cormat[melted_cormat$Var1=='price',]
#sqft_living, sqft_above and grades are highly related.
#price has high correlation with sqft_living, grade, bathrooms
melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
melted_cormat[melted_cormat$Var1=='price',]
cormat <- cor(myD[,-1])
round(cormat, 2)
melted_cormat <- melt(cormat)
cormat <- reorder_cormat(cormat)
upper_tri <- get_lower_tri(cormat)
#sqft_living, sqft_above and grades are highly related.
#price has high correlation with sqft_living, grade, bathrooms
melted_cormat_byValue <- melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
melted_cormat_byValue_price <- melted_cormat_byValue[melted_cormat_byValue$Var1=='price',]
melted_cormat_byValue_price
##set up
# setwd("C:/Users/Jin/Desktop/MATH564Project")
myD<-read.csv("../kc_house_data.csv",stringsAsFactors = FALSE)
##set up
# setwd("C:/Users/Jin/Desktop/MATH564Project")
myD<-read.csv("./kc_house_data.csv",stringsAsFactors = FALSE)
summary(myD)
str(myD)
#the data is pretty clean. No NAs and most of them are int/num.
#we can just drop the first two columns, id and dates.
# myD$date <- as.Date(substring(myD$date, 0, 8), "%Y%m%d")
myD <- myD[, -c(1,2)]
myD
## forward, backward variable selection
#forward
fit2.AIC <- stepAIC(fit2, scope = list(upper = fit2, lower = model.null), trace = FALSE)
## forward, backward variable selection
#forward
formula.null <- as.formula("Price ~ 1")
model.null <- lm(formula.null, data = myD)
## forward, backward variable selection
#forward
formula.null <- as.formula("price ~ 1")
model.null <- lm(formula.null, data = myD)
fit2.AIC <- stepAIC(basic_fit, scope = list(lower = model.null), trace = FALSE)
?stepAIC
??stepAIC
library(MASS)
fit2.AIC <- stepAIC(basic_fit, scope = list(lower = model.null), trace = FALSE)
# helper functions
# get lower triangle of the matrix
get_lower_tri<-function(cormat){
cormat[upper.tri(cormat)] <- NA
return(cormat)
}
# reorder the correlation values
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
# Math 564 project
# read data
library(ggplot2)
library(reshape2)
library(MASS)
##set up
# setwd("C:/Users/Jin/Desktop/MATH564Project")
myD<-read.csv("./kc_house_data.csv",stringsAsFactors = FALSE)
summary(myD)
str(myD)
#the data is pretty clean. No NAs and most of them are int/num.
#we can just drop the first two columns, id and dates.
myD <- myD[, -c(1,2)]
##correlations
# pair matrix without dates
cormat <- cor(myD)
round(cormat, 2)
melted_cormat <- melt(cormat)
cormat <- reorder_cormat(cormat)
upper_tri <- get_lower_tri(cormat)
# upper_tri
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# create correlation heatmap
ggheatmap <- ggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
geom_tile(color = "white")+
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1), space = "Lab",
name="Pearson\nCorrelation") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, vjust = 1,
size = 12, hjust = 1))+
coord_fixed()
# sqft_living, sqft_above and grades are highly related.
# price has high correlation with sqft_living, grade, sqrt_above, and bathrooms.
melted_cormat_byValue <- melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
melted_cormat_byValue_price <- melted_cormat_byValue[melted_cormat_byValue$Var1=='price',]
## boxplots for some high-correlated variables and price
boxplot_p_sl <- boxplot(price~sqft_living, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_b <- boxplot(price~bathrooms, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Bathrooms", xlab="Bathrooms", ylab="Price")
boxplot_p_g <- boxplot(price~grade, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Grade", xlab="Grade", ylab="Price")
## simple linear model
basic_fit <- lm(price~., data = myD)
summary(basic_fit)
# coef of sqft_basement is NA
## forward, backward variable selection
#forward
formula.null <- as.formula("price ~ 1")
model.null <- lm(formula.null, data = myD)
fit2.AIC <- stepAIC(basic_fit, scope = list(lower = model.null), trace = FALSE)
fit2.AIC$formula
basic_fi
basic_fit
## backward variable selection
#backward
formula.null <- as.formula("price ~ 1")
model.null <- lm(formula.null, data = myD)
fit2.BIC <- step(basic_fit, direction = "backward", k=log(nrow(myD)))
fit2.BIC$formula
## backward variable selection
#backward
model.null <- lm(price~, data = myD)
## backward variable selection
#backward
model.null <- lm(price~., data = myD)
fit2.BIC <- step(basic_fit, direction = "backward", k=log(nrow(myD)))
fit2.BIC$formula
summary(fit2.BIC)
summary(basic_fit)
# coef of sqft_basement is NA
fit_drop_basement <- lm(price~.-sqft_basement, data = myD)
summary(fit_drop_basement)
## backward variable selection
#backward
model.null <- lm(price~., data = myD)
fit2.BIC <- step(fit_drop_basement, direction = "backward", k=log(nrow(myD)))
fit2.BIC$formula
summary(fit_drop_basement)
## simplified model
sim_fit <- lm(price~sqft_living+bathrooms+grade)
## simplified model
sim_fit <- lm(price~sqft_living+bathrooms+grade, data = myD)
summary(sim_fit)
melted_cormat_byValue_price
# sqft_living, sqft_above and grades are highly related.
# price has high correlation with sqft_living, grade, sqrt_above, and bathrooms.
melted_cormat_byValue <- melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
melted_cormat_byValue_price <- melted_cormat_byValue[melted_cormat_byValue$Var1=='price',]
melted_cormat_byValue_price
melted_cormat_byValue
melted_cormat_byValue_price
melted_cormat_byValue_price1 <- melted_cormat_byValue[melted_cormat_byValue$Var1=='price',]
melted_cormat_byValue_price2 <- melted_cormat_byValue[melted_cormat_byValue$Var2=='price',]
melted_cormat_byValue_price2
??melt
??merge
melted_cormat_byValue_price1
melted_cormat_byValue_price <- merge(melted_cormat_byValue_price1, melted_cormat_byValue_price2,
by.x = Var1, by.y = Var2)
melted_cormat_byValue_price <- merge(melted_cormat_byValue_price1, melted_cormat_byValue_price2,
by.x = 'Var1', by.y = 'Var2')
melted_cormat_byValue[melted_cormat_byValue$Var1=='price' || melted_cormat_byValue$Var2=='price',]
melted_cormat_byValue[melted_cormat_byValue$Var1=='price' | melted_cormat_byValue$Var2=='price',]
# sqft_living, sqft_above and grades are highly related.
# price has high correlation with sqft_living, grade, sqrt_above, and bathrooms.
melted_cormat_byValue <- melted_cormat[order(abs(melted_cormat$value), decreasing = T),]
melted_cormat_byValue_price <- melted_cormat_byValue[melted_cormat_byValue$Var1=='price' |
melted_cormat_byValue$Var2=='price',]
melted_cormat_byValue_price
library(MASS)
#AIC
fit2.AIC <- stepAIC(fit_drop_basement, scope = list(upper = fit_drop_basement, lower = model.null), trace = FALSE)
## backward variable selection
model.null <- lm(price~ 1, data = myD)
#AIC
fit2.AIC <- stepAIC(fit_drop_basement, scope = list(upper = fit_drop_basement, lower = model.null), trace = FALSE)
fit2.AIC$formula
#BIC
fit2.BIC <- step(fit_drop_basement, direction = "backward", k=log(nrow(myD)))
fit2.BIC$formula
fit2.AIC$formula
model.null
## boxplots for some high-correlated variables and price
boxplot_p_sl <- boxplot(price~sqft_living, data=myD,
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_sl
## backward variable selection
model.null <- lm(price~ 1, data = myD)
model.backward <- step(sim_fit, scope = list(lower = model.null),
direction = "backward", test = "Chisq", data = myData1, trace = F)
model.backward$formula
model.backward <- step(sim_fit, scope = list(lower = model.null),
direction = "backward", test = "Chisq", data = myD, trace = F)
model.backward$formula
model.backward <- step(fit_drop_basement, scope = list(lower = model.null),
direction = "backward", test = "Chisq", data = myD, trace = F)
model.backward$formula
summary(full.model)
## full linear model
full.model <- lm(price~., data = myD)
summary(full.model)
# coef of sqft_basement is NA
fit_drop_basement <- lm(price~.-sqft_basement, data = myD)
# coef of sqft_basement is NA
# R^2 = 0.6997, adR^2 = 0.6995
fit_drop_basement <- lm(price~.-sqft_basement, data = myD)
summary(fit_drop_basement)
## simplified model
sim_fit <- lm(price~sqft_living+bathrooms+grade, data = myD)
## simplified model
sim_fit <- lm(price~sqft_living+grade+sqrt_above+sqft_living15+bathrooms, data = myD)
## simplified model
sim_fit <- lm(price~sqft_living+grade+sqft_above+sqft_living15+bathrooms, data = myD)
summary(sim_fit)
# select best model by adj R^2
best <- function(model, ...)
{
subsets <- regsubsets(formula(model), model.frame(model), ...)
subsets <- with(summary(subsets),
cbind(p = as.numeric(rownames(which)), which, adjr2))
return(subsets)
}
library(leaps)
# R^2 = 0.5442, adR^2 = 0.5441
# select model by adjusted R^2
# fit2 <- lm(Y~X1+X2+X3+I(X1^2)+I(X2^2)+I(X3^2)+I(X1*X2)+I(X1*X3)+I(X2*X3), data = myData1)
result <- as.data.frame(round(best(fit_drop_basement, nbest = 6), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
# R^2 = 0.5442, adR^2 = 0.5441
# select model by adjusted R^2
# fit2 <- lm(Y~X1+X2+X3+I(X1^2)+I(X2^2)+I(X3^2)+I(X1*X2)+I(X1*X3)+I(X2*X3), data = myData1)
result <- as.data.frame(round(best(fit_drop_basement, nbest = 3), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
# R^2 = 0.5442, adR^2 = 0.5441
# select model by adjusted R^2
# fit2 <- lm(Y~X1+X2+X3+I(X1^2)+I(X2^2)+I(X3^2)+I(X1*X2)+I(X1*X3)+I(X2*X3), data = myData1)
result <- as.data.frame(round(best(fit_drop_basement, nbest = 3), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
# R^2 = 0.5442, adR^2 = 0.5441
# select model by adjusted R^2
# fit2 <- lm(Y~X1+X2+X3+I(X1^2)+I(X2^2)+I(X3^2)+I(X1*X2)+I(X1*X3)+I(X2*X3), data = myData1)
result <- as.data.frame(round(best(fit_drop_basement, nbest = 6), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
summary(full.model)
summary(fit_drop_basement)
head(result)
# R^2 = 0.5442, adjR^2 = 0.5441
# select model by adjusted R^2
result <- as.data.frame(round(best(fit_drop_basement, nbest = 3), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
lm(price ~ bedrooms + bathrooms + sqft_living + waterfront + view + grade + yr_built + lat + sqft_basement, data = myD)
summary(lm(price ~ bedrooms + bathrooms + sqft_living + waterfront + view + grade + yr_built + lat + sqft_basement, data = myD))
## backward variable selection
model.null <- lm(price ~ 1, data = myD)
model.backward <- step(fit_drop_basement, scope = list(lower = model.null),
direction = "backward", test = "Chisq", data = myD, trace = F)
model.backward$formula
ggheatmap
melted_cormat_byValue_price
summary(full.model)
# coef of sqft_basement is NA, and p-value of floor > 0.05
# R^2 = 0.6997, adR^2 = 0.6995
fit_drop_basement_floors <- lm(price~.-sqft_basement-floors, data = myD)
summary(fit_drop_basement_floors)
boxplot_p_sl
## boxplots for some high-correlated variables and price
boxplot_p_sl <- boxplot(price~sqft_living, data=myD,
main="Price vs. Sqft_living", xlab="Sqft_living", ylab="Price")
boxplot_p_b <- boxplot(price~bathrooms, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Bathrooms", xlab="Bathrooms", ylab="Price")
boxplot_p_g <- boxplot(price~grade, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Grade", xlab="Grade", ylab="Price")
boxplot_p_b <- boxplot(price~bathrooms, data=myD,
col=(c("gold","darkgreen")),
main="Price vs. Bathrooms", xlab="Bathrooms", ylab="Price")
## log price
log_price_model <- lm(log(price)~., data = myD)
summary(log_price_model)
## log price
log_price_model <- lm(log(price)~.-sqft_basement, data = myD)
summary(log_price_model)
# R^2 = 0.7704, adR^2 = 0.7703
result <- as.data.frame(round(best(log_price_model, nbest = 3), 4))
## log price
log_price_model <- lm(log(price)~.-sqft_basement, data = myD)
summary(log_price_model)
## log price
myD$logP <- log(myD$price)
## log price
myD$logP <- log(myD$price)
myD
myD <- myD[,-1]
log_price_model <- lm(logP~.-sqft_basement, data = myD)
summary(log_price_model)
# R^2 = 0.7704, adR^2 = 0.7703
result <- as.data.frame(round(best(log_price_model, nbest = 3), 4))
result <- result[order(-abs(result$adjr2)),]
head(result)
